{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _extends from \"@babel/runtime/helpers/extends\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nimport { CodedError, RCTDeviceEventEmitter, UnavailabilityError } from '@unimodules/core';\nimport Constants from 'expo-constants';\nimport { EventEmitter } from 'fbemitter';\nimport invariant from 'invariant';\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport ExponentNotifications from \"./ExponentNotifications\";\nimport Storage from \"./Storage\";\nvar _emitter;\nvar _initialNotification;\nfunction _maybeInitEmitter() {\n  if (!_emitter) {\n    _emitter = new EventEmitter();\n    RCTDeviceEventEmitter.addListener('Exponent.notification', emitNotification);\n  }\n}\nexport function emitNotification(notification) {\n  if (typeof notification === 'string') {\n    notification = JSON.parse(notification);\n  }\n  notification = _objectSpread({}, notification);\n  if (typeof notification.data === 'string') {\n    try {\n      notification.data = JSON.parse(notification.data);\n    } catch (e) {}\n  }\n  _emitter.emit('notification', notification);\n}\nfunction _processNotification(notification) {\n  notification = _extends({}, notification);\n  if (!notification.data) {\n    notification.data = {};\n  }\n  if (notification.hasOwnProperty('count')) {\n    delete notification.count;\n  }\n  if (Platform.OS === 'ios') {\n    if (notification.android) {\n      delete notification.android;\n    }\n    if (notification.ios) {\n      notification = _extends(notification, notification.ios);\n      notification.data._displayInForeground = notification.ios._displayInForeground;\n      delete notification.ios;\n    }\n  }\n  if (Platform.OS === 'android') {\n    if (notification.ios) {\n      delete notification.ios;\n    }\n    if (notification.android) {\n      notification = _extends(notification, notification.android);\n      delete notification.android;\n    }\n  }\n  return notification;\n}\nfunction _validateNotification(notification) {\n  if (Platform.OS === 'ios') {\n    invariant(!!notification.title && !!notification.body, 'Local notifications on iOS require both a title and a body');\n  } else if (Platform.OS === 'android') {\n    invariant(!!notification.title, 'Local notifications on Android require a title');\n  }\n}\nvar ASYNC_STORAGE_PREFIX = '__expo_internal_channel_';\nvar IS_USING_NEW_BINARY = ExponentNotifications && typeof ExponentNotifications.createChannel === 'function';\nfunction _legacyReadChannel(id) {\n  var channelString;\n  return _regeneratorRuntime.async(function _legacyReadChannel$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _context.prev = 0;\n          _context.next = 3;\n          return _regeneratorRuntime.awrap(Storage.getItem(\"\" + ASYNC_STORAGE_PREFIX + id));\n        case 3:\n          channelString = _context.sent;\n          if (!channelString) {\n            _context.next = 6;\n            break;\n          }\n          return _context.abrupt(\"return\", JSON.parse(channelString));\n        case 6:\n          _context.next = 10;\n          break;\n        case 8:\n          _context.prev = 8;\n          _context.t0 = _context[\"catch\"](0);\n        case 10:\n          return _context.abrupt(\"return\", null);\n        case 11:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, [[0, 8]], Promise);\n}\nfunction _legacyDeleteChannel(id) {\n  return Storage.removeItem(\"\" + ASYNC_STORAGE_PREFIX + id);\n}\nif (Platform.OS === 'android') {\n  Storage.clear = function _callee(callback) {\n    var keys, filteredKeys;\n    return _regeneratorRuntime.async(function _callee$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.prev = 0;\n            _context2.next = 3;\n            return _regeneratorRuntime.awrap(Storage.getAllKeys());\n          case 3:\n            keys = _context2.sent;\n            if (!(keys && keys.length)) {\n              _context2.next = 8;\n              break;\n            }\n            filteredKeys = keys.filter(function (key) {\n              return !key.startsWith(ASYNC_STORAGE_PREFIX);\n            });\n            _context2.next = 8;\n            return _regeneratorRuntime.awrap(Storage.multiRemove(filteredKeys));\n          case 8:\n            callback && callback();\n            _context2.next = 15;\n            break;\n          case 11:\n            _context2.prev = 11;\n            _context2.t0 = _context2[\"catch\"](0);\n            callback && callback(_context2.t0);\n            throw _context2.t0;\n          case 15:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, null, null, [[0, 11]], Promise);\n  };\n}\nfunction _legacySaveChannel(id, channel) {\n  return Storage.setItem(\"\" + ASYNC_STORAGE_PREFIX + id, JSON.stringify(channel));\n}\nexport default {\n  _setInitialNotification: function _setInitialNotification(notification) {\n    _initialNotification = notification;\n  },\n  createCategoryAsync: function createCategoryAsync(categoryId, actions, previewPlaceholder) {\n    return Platform.OS === 'ios' ? ExponentNotifications.createCategoryAsync(categoryId, actions, previewPlaceholder) : ExponentNotifications.createCategoryAsync(categoryId, actions);\n  },\n  deleteCategoryAsync: function deleteCategoryAsync(categoryId) {\n    return ExponentNotifications.deleteCategoryAsync(categoryId);\n  },\n  getExpoPushTokenAsync: function getExpoPushTokenAsync() {\n    if (!ExponentNotifications.getExponentPushTokenAsync) {\n      throw new UnavailabilityError('Expo.Notifications', 'getExpoPushTokenAsync');\n    }\n    if (!Constants.isDevice) {\n      throw new Error(\"Must be on a physical device to get an Expo Push Token\");\n    }\n    return ExponentNotifications.getExponentPushTokenAsync();\n  },\n  getDevicePushTokenAsync: function getDevicePushTokenAsync(config) {\n    if (!ExponentNotifications.getDevicePushTokenAsync) {\n      throw new UnavailabilityError('Expo.Notifications', 'getDevicePushTokenAsync');\n    }\n    return ExponentNotifications.getDevicePushTokenAsync(config || {});\n  },\n  createChannelAndroidAsync: function createChannelAndroidAsync(id, channel) {\n    if (Platform.OS !== 'android') {\n      console.warn(\"createChannelAndroidAsync(...) has no effect on \" + Platform.OS);\n      return Promise.resolve();\n    }\n    if (!IS_USING_NEW_BINARY) {\n      return _legacySaveChannel(id, channel);\n    }\n    return ExponentNotifications.createChannel(id, channel);\n  },\n  deleteChannelAndroidAsync: function deleteChannelAndroidAsync(id) {\n    if (Platform.OS !== 'android') {\n      console.warn(\"deleteChannelAndroidAsync(...) has no effect on \" + Platform.OS);\n      return Promise.resolve();\n    }\n    if (!IS_USING_NEW_BINARY) {\n      return Promise.resolve();\n    }\n    return ExponentNotifications.deleteChannel(id);\n  },\n  presentLocalNotificationAsync: function presentLocalNotificationAsync(notification) {\n    var nativeNotification, _channel;\n    return _regeneratorRuntime.async(function presentLocalNotificationAsync$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _validateNotification(notification);\n            nativeNotification = _processNotification(notification);\n            if (!(Platform.OS !== 'android')) {\n              _context3.next = 8;\n              break;\n            }\n            _context3.next = 5;\n            return _regeneratorRuntime.awrap(ExponentNotifications.presentLocalNotification(nativeNotification));\n          case 5:\n            return _context3.abrupt(\"return\", _context3.sent);\n          case 8:\n            if (!nativeNotification.channelId) {\n              _context3.next = 12;\n              break;\n            }\n            _context3.next = 11;\n            return _regeneratorRuntime.awrap(_legacyReadChannel(nativeNotification.channelId));\n          case 11:\n            _channel = _context3.sent;\n          case 12:\n            if (!IS_USING_NEW_BINARY) {\n              _context3.next = 17;\n              break;\n            }\n            _legacyDeleteChannel(nativeNotification.channelId);\n            return _context3.abrupt(\"return\", ExponentNotifications.presentLocalNotificationWithChannel(nativeNotification, _channel));\n          case 17:\n            if (_channel) {\n              nativeNotification.sound = _channel.sound;\n              nativeNotification.priority = _channel.priority;\n              nativeNotification.vibrate = _channel.vibrate;\n            }\n            return _context3.abrupt(\"return\", ExponentNotifications.presentLocalNotification(nativeNotification));\n          case 19:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  scheduleLocalNotificationAsync: function scheduleLocalNotificationAsync(notification) {\n    var options,\n      now,\n      nativeNotification,\n      timeAsDateObj,\n      validOptions,\n      _channel,\n      _args4 = arguments;\n    return _regeneratorRuntime.async(function scheduleLocalNotificationAsync$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            options = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {};\n            now = Date.now();\n            _validateNotification(notification);\n            nativeNotification = _processNotification(notification);\n            if (!options.time) {\n              _context4.next = 11;\n              break;\n            }\n            timeAsDateObj = null;\n            if (options.time && typeof options.time === 'number') {\n              timeAsDateObj = new Date(options.time);\n              if (timeAsDateObj.toString() === 'Invalid Date') {\n                timeAsDateObj = null;\n              }\n            } else if (options.time && options.time instanceof Date) {\n              timeAsDateObj = options.time;\n            }\n            if (timeAsDateObj) {\n              _context4.next = 9;\n              break;\n            }\n            throw new Error(\"Provided value for \\\"time\\\" is invalid. Please verify that it's either a number representing Unix Epoch time in milliseconds, or a valid date object.\");\n          case 9:\n            if (timeAsDateObj.getTime() < now) {\n              console.warn(\"Provided value for \\\"time\\\" is before the current date. Did you possibly pass number of seconds since Unix Epoch instead of number of milliseconds?\");\n            }\n            options = _objectSpread(_objectSpread({}, options), {}, {\n              time: timeAsDateObj.getTime()\n            });\n          case 11:\n            if (!(options.intervalMs != null && options.repeat != null)) {\n              _context4.next = 13;\n              break;\n            }\n            throw new Error(\"Pass either the \\\"repeat\\\" option or \\\"intervalMs\\\" option, not both\");\n          case 13:\n            if (!(options.repeat != null)) {\n              _context4.next = 17;\n              break;\n            }\n            validOptions = new Set(['minute', 'hour', 'day', 'week', 'month', 'year']);\n            if (validOptions.has(options.repeat)) {\n              _context4.next = 17;\n              break;\n            }\n            throw new Error(\"Pass one of ['minute', 'hour', 'day', 'week', 'month', 'year'] as the value for the \\\"repeat\\\" option\");\n          case 17:\n            if (!(options.intervalMs != null)) {\n              _context4.next = 22;\n              break;\n            }\n            if (!(Platform.OS === 'ios')) {\n              _context4.next = 20;\n              break;\n            }\n            throw new Error(\"The \\\"intervalMs\\\" option is not supported on iOS\");\n          case 20:\n            if (!(options.intervalMs <= 0 || !Number.isInteger(options.intervalMs))) {\n              _context4.next = 22;\n              break;\n            }\n            throw new Error(\"Pass an integer greater than zero as the value for the \\\"intervalMs\\\" option\");\n          case 22:\n            if (!(Platform.OS !== 'android')) {\n              _context4.next = 29;\n              break;\n            }\n            if (!options.repeat) {\n              _context4.next = 26;\n              break;\n            }\n            console.warn('Ability to schedule an automatically repeated notification is deprecated on iOS and will be removed in the next SDK release.');\n            return _context4.abrupt(\"return\", ExponentNotifications.legacyScheduleLocalRepeatingNotification(nativeNotification, options));\n          case 26:\n            return _context4.abrupt(\"return\", ExponentNotifications.scheduleLocalNotification(nativeNotification, options));\n          case 29:\n            if (!nativeNotification.channelId) {\n              _context4.next = 33;\n              break;\n            }\n            _context4.next = 32;\n            return _regeneratorRuntime.awrap(_legacyReadChannel(nativeNotification.channelId));\n          case 32:\n            _channel = _context4.sent;\n          case 33:\n            if (!IS_USING_NEW_BINARY) {\n              _context4.next = 38;\n              break;\n            }\n            _legacyDeleteChannel(nativeNotification.channelId);\n            return _context4.abrupt(\"return\", ExponentNotifications.scheduleLocalNotificationWithChannel(nativeNotification, options, _channel));\n          case 38:\n            if (_channel) {\n              nativeNotification.sound = _channel.sound;\n              nativeNotification.priority = _channel.priority;\n              nativeNotification.vibrate = _channel.vibrate;\n            }\n            return _context4.abrupt(\"return\", ExponentNotifications.scheduleLocalNotification(nativeNotification, options));\n          case 40:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  dismissNotificationAsync: function dismissNotificationAsync(notificationId) {\n    return _regeneratorRuntime.async(function dismissNotificationAsync$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            if (ExponentNotifications.dismissNotification) {\n              _context5.next = 2;\n              break;\n            }\n            throw new UnavailabilityError('Expo.Notifications', 'dismissNotification');\n          case 2:\n            _context5.next = 4;\n            return _regeneratorRuntime.awrap(ExponentNotifications.dismissNotification(notificationId));\n          case 4:\n            return _context5.abrupt(\"return\", _context5.sent);\n          case 5:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  dismissAllNotificationsAsync: function dismissAllNotificationsAsync() {\n    return _regeneratorRuntime.async(function dismissAllNotificationsAsync$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            if (ExponentNotifications.dismissAllNotifications) {\n              _context6.next = 2;\n              break;\n            }\n            throw new UnavailabilityError('Expo.Notifications', 'dismissAllNotifications');\n          case 2:\n            _context6.next = 4;\n            return _regeneratorRuntime.awrap(ExponentNotifications.dismissAllNotifications());\n          case 4:\n            return _context6.abrupt(\"return\", _context6.sent);\n          case 5:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  cancelScheduledNotificationAsync: function cancelScheduledNotificationAsync(notificationId) {\n    if (Platform.OS === 'android' && typeof notificationId === 'string') {\n      return ExponentNotifications.cancelScheduledNotificationWithStringIdAsync(notificationId);\n    }\n    return ExponentNotifications.cancelScheduledNotificationAsync(notificationId);\n  },\n  cancelAllScheduledNotificationsAsync: function cancelAllScheduledNotificationsAsync() {\n    return ExponentNotifications.cancelAllScheduledNotificationsAsync();\n  },\n  addListener: function addListener(listener) {\n    _maybeInitEmitter();\n    if (_initialNotification) {\n      var initialNotification = _initialNotification;\n      _initialNotification = null;\n      setTimeout(function () {\n        emitNotification(initialNotification);\n      }, 0);\n    }\n    return _emitter.addListener('notification', listener);\n  },\n  getBadgeNumberAsync: function getBadgeNumberAsync() {\n    return _regeneratorRuntime.async(function getBadgeNumberAsync$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            if (ExponentNotifications.getBadgeNumberAsync) {\n              _context7.next = 2;\n              break;\n            }\n            return _context7.abrupt(\"return\", 0);\n          case 2:\n            return _context7.abrupt(\"return\", ExponentNotifications.getBadgeNumberAsync());\n          case 3:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  setBadgeNumberAsync: function setBadgeNumberAsync(number) {\n    return _regeneratorRuntime.async(function setBadgeNumberAsync$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            if (ExponentNotifications.setBadgeNumberAsync) {\n              _context8.next = 2;\n              break;\n            }\n            throw new UnavailabilityError('Expo.Notifications', 'setBadgeNumberAsync');\n          case 2:\n            return _context8.abrupt(\"return\", ExponentNotifications.setBadgeNumberAsync(number));\n          case 3:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  scheduleNotificationWithCalendarAsync: function scheduleNotificationWithCalendarAsync(notification) {\n    var options,\n      areOptionsValid,\n      nativeNotification,\n      _args9 = arguments;\n    return _regeneratorRuntime.async(function scheduleNotificationWithCalendarAsync$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            options = _args9.length > 1 && _args9[1] !== undefined ? _args9[1] : {};\n            areOptionsValid = (options.month == null || isInRangeInclusive(options.month, 1, 12)) && (options.day == null || isInRangeInclusive(options.day, 1, 31)) && (options.hour == null || isInRangeInclusive(options.hour, 0, 23)) && (options.minute == null || isInRangeInclusive(options.minute, 0, 59)) && (options.second == null || isInRangeInclusive(options.second, 0, 59)) && (options.weekDay == null || isInRangeInclusive(options.weekDay, 1, 7)) && (options.weekDay == null || options.day == null);\n            if (areOptionsValid) {\n              _context9.next = 4;\n              break;\n            }\n            throw new CodedError('WRONG_OPTIONS', 'Options in scheduleNotificationWithCalendarAsync call were incorrect!');\n          case 4:\n            _validateNotification(notification);\n            nativeNotification = _processNotification(notification);\n            return _context9.abrupt(\"return\", ExponentNotifications.scheduleNotificationWithCalendar(nativeNotification, options));\n          case 7:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  scheduleNotificationWithTimerAsync: function scheduleNotificationWithTimerAsync(notification, options) {\n    var nativeNotification;\n    return _regeneratorRuntime.async(function scheduleNotificationWithTimerAsync$(_context10) {\n      while (1) {\n        switch (_context10.prev = _context10.next) {\n          case 0:\n            if (!(options.interval < 1)) {\n              _context10.next = 2;\n              break;\n            }\n            throw new CodedError('WRONG_OPTIONS', 'Interval must be not less then 1');\n          case 2:\n            _validateNotification(notification);\n            nativeNotification = _processNotification(notification);\n            return _context10.abrupt(\"return\", ExponentNotifications.scheduleNotificationWithTimer(nativeNotification, options));\n          case 5:\n          case \"end\":\n            return _context10.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  }\n};\nfunction isInRangeInclusive(variable, min, max) {\n  return variable >= min && variable <= max;\n}","map":{"version":3,"names":["CodedError","RCTDeviceEventEmitter","UnavailabilityError","Constants","EventEmitter","invariant","Platform","ExponentNotifications","Storage","_emitter","_initialNotification","_maybeInitEmitter","addListener","emitNotification","notification","JSON","parse","_objectSpread","data","e","emit","_processNotification","_extends","hasOwnProperty","count","OS","android","ios","_displayInForeground","_validateNotification","title","body","ASYNC_STORAGE_PREFIX","IS_USING_NEW_BINARY","createChannel","_legacyReadChannel","id","channelString","_regeneratorRuntime","async","_legacyReadChannel$","_context","prev","next","awrap","getItem","sent","abrupt","t0","stop","Promise","_legacyDeleteChannel","removeItem","clear","_callee","callback","keys","filteredKeys","_callee$","_context2","getAllKeys","length","filter","key","startsWith","multiRemove","_legacySaveChannel","channel","setItem","stringify","_setInitialNotification","createCategoryAsync","categoryId","actions","previewPlaceholder","deleteCategoryAsync","getExpoPushTokenAsync","getExponentPushTokenAsync","isDevice","Error","getDevicePushTokenAsync","config","createChannelAndroidAsync","console","warn","resolve","deleteChannelAndroidAsync","deleteChannel","presentLocalNotificationAsync","nativeNotification","_channel","presentLocalNotificationAsync$","_context3","presentLocalNotification","channelId","presentLocalNotificationWithChannel","sound","priority","vibrate","scheduleLocalNotificationAsync","options","now","timeAsDateObj","validOptions","_args4","arguments","scheduleLocalNotificationAsync$","_context4","undefined","Date","time","toString","getTime","intervalMs","repeat","Set","has","Number","isInteger","legacyScheduleLocalRepeatingNotification","scheduleLocalNotification","scheduleLocalNotificationWithChannel","dismissNotificationAsync","notificationId","dismissNotificationAsync$","_context5","dismissNotification","dismissAllNotificationsAsync","dismissAllNotificationsAsync$","_context6","dismissAllNotifications","cancelScheduledNotificationAsync","cancelScheduledNotificationWithStringIdAsync","cancelAllScheduledNotificationsAsync","listener","initialNotification","setTimeout","getBadgeNumberAsync","getBadgeNumberAsync$","_context7","setBadgeNumberAsync","number","setBadgeNumberAsync$","_context8","scheduleNotificationWithCalendarAsync","areOptionsValid","_args9","scheduleNotificationWithCalendarAsync$","_context9","month","isInRangeInclusive","day","hour","minute","second","weekDay","scheduleNotificationWithCalendar","scheduleNotificationWithTimerAsync","scheduleNotificationWithTimerAsync$","_context10","interval","scheduleNotificationWithTimer","variable","min","max"],"sources":["/Users/wesli/Documents/GitHub/stuport2/node_modules/expo/src/Notifications/Notifications.ts"],"sourcesContent":["import { CodedError, RCTDeviceEventEmitter, UnavailabilityError } from '@unimodules/core';\nimport Constants from 'expo-constants';\nimport { EventEmitter, EventSubscription } from 'fbemitter';\nimport invariant from 'invariant';\nimport { Platform } from 'react-native';\n\nimport ExponentNotifications from './ExponentNotifications';\nimport {\n  Notification,\n  LocalNotification,\n  Channel,\n  ActionType,\n  LocalNotificationId,\n} from './Notifications.types';\nimport Storage from './Storage';\n\nlet _emitter;\nlet _initialNotification;\n\nfunction _maybeInitEmitter() {\n  if (!_emitter) {\n    _emitter = new EventEmitter();\n    RCTDeviceEventEmitter.addListener('Exponent.notification', emitNotification);\n  }\n}\n\nexport function emitNotification(notification) {\n  if (typeof notification === 'string') {\n    notification = JSON.parse(notification);\n  }\n\n  /* Don't mutate the original notification */\n  notification = { ...notification };\n\n  if (typeof notification.data === 'string') {\n    try {\n      notification.data = JSON.parse(notification.data);\n    } catch (e) {\n      // It's actually just a string, that's fine\n    }\n  }\n\n  _emitter.emit('notification', notification);\n}\n\nfunction _processNotification(notification) {\n  notification = Object.assign({}, notification);\n\n  if (!notification.data) {\n    notification.data = {};\n  }\n\n  if (notification.hasOwnProperty('count')) {\n    delete notification.count;\n  }\n\n  // Delete any Android properties on iOS and merge the iOS properties on root notification object\n  if (Platform.OS === 'ios') {\n    if (notification.android) {\n      delete notification.android;\n    }\n\n    if (notification.ios) {\n      notification = Object.assign(notification, notification.ios);\n      notification.data._displayInForeground = notification.ios._displayInForeground;\n      delete notification.ios;\n    }\n  }\n\n  // Delete any iOS properties on Android and merge the Android properties on root notification\n  // object\n  if (Platform.OS === 'android') {\n    if (notification.ios) {\n      delete notification.ios;\n    }\n\n    if (notification.android) {\n      notification = Object.assign(notification, notification.android);\n      delete notification.android;\n    }\n  }\n\n  return notification;\n}\n\nfunction _validateNotification(notification) {\n  if (Platform.OS === 'ios') {\n    invariant(\n      !!notification.title && !!notification.body,\n      'Local notifications on iOS require both a title and a body'\n    );\n  } else if (Platform.OS === 'android') {\n    invariant(!!notification.title, 'Local notifications on Android require a title');\n  }\n}\n\nconst ASYNC_STORAGE_PREFIX = '__expo_internal_channel_';\n// TODO: remove this before releasing\n// this will always be `true` for SDK 28+\nconst IS_USING_NEW_BINARY =\n  ExponentNotifications && typeof ExponentNotifications.createChannel === 'function';\n\nasync function _legacyReadChannel(id: string): Promise<Channel | null> {\n  try {\n    const channelString = await Storage.getItem(`${ASYNC_STORAGE_PREFIX}${id}`);\n    if (channelString) {\n      return JSON.parse(channelString);\n    }\n  } catch (e) {}\n  return null;\n}\n\nfunction _legacyDeleteChannel(id: string): Promise<void> {\n  return Storage.removeItem(`${ASYNC_STORAGE_PREFIX}${id}`);\n}\n\nif (Platform.OS === 'android') {\n  Storage.clear = async function(callback?: (error?: Error) => void): Promise<void> {\n    try {\n      const keys = await Storage.getAllKeys();\n      if (keys && keys.length) {\n        const filteredKeys = keys.filter(key => !key.startsWith(ASYNC_STORAGE_PREFIX));\n        await Storage.multiRemove(filteredKeys);\n      }\n      callback && callback();\n    } catch (e) {\n      callback && callback(e);\n      throw e;\n    }\n  };\n}\n\n// This codepath will never be triggered in SDK 28 and above\n// TODO: remove before releasing\nfunction _legacySaveChannel(id: string, channel: Channel): Promise<void> {\n  return Storage.setItem(`${ASYNC_STORAGE_PREFIX}${id}`, JSON.stringify(channel));\n}\n\nexport default {\n  /* Only used internally to initialize the notification from top level props */\n  _setInitialNotification(notification: Notification) {\n    _initialNotification = notification;\n  },\n\n  // User passes set of actions titles.\n  createCategoryAsync(\n    categoryId: string,\n    actions: ActionType[],\n    previewPlaceholder?: string\n  ): Promise<void> {\n    return Platform.OS === 'ios'\n      ? ExponentNotifications.createCategoryAsync(categoryId, actions, previewPlaceholder)\n      : ExponentNotifications.createCategoryAsync(categoryId, actions);\n  },\n\n  deleteCategoryAsync(categoryId: string): Promise<void> {\n    return ExponentNotifications.deleteCategoryAsync(categoryId);\n  },\n\n  /* Re-export */\n  getExpoPushTokenAsync(): Promise<string> {\n    if (!ExponentNotifications.getExponentPushTokenAsync) {\n      throw new UnavailabilityError('Expo.Notifications', 'getExpoPushTokenAsync');\n    }\n    if (!Constants.isDevice) {\n      throw new Error(`Must be on a physical device to get an Expo Push Token`);\n    }\n    return ExponentNotifications.getExponentPushTokenAsync();\n  },\n\n  getDevicePushTokenAsync: (config: {\n    gcmSenderId?: string;\n  }): Promise<{ type: string; data: string }> => {\n    if (!ExponentNotifications.getDevicePushTokenAsync) {\n      throw new UnavailabilityError('Expo.Notifications', 'getDevicePushTokenAsync');\n    }\n    return ExponentNotifications.getDevicePushTokenAsync(config || {});\n  },\n\n  createChannelAndroidAsync(id: string, channel: Channel): Promise<void> {\n    if (Platform.OS !== 'android') {\n      console.warn(`createChannelAndroidAsync(...) has no effect on ${Platform.OS}`);\n      return Promise.resolve();\n    }\n    // This codepath will never be triggered in SDK 28 and above\n    // TODO: remove before releasing\n    if (!IS_USING_NEW_BINARY) {\n      return _legacySaveChannel(id, channel);\n    }\n    return ExponentNotifications.createChannel(id, channel);\n  },\n\n  deleteChannelAndroidAsync(id: string): Promise<void> {\n    if (Platform.OS !== 'android') {\n      console.warn(`deleteChannelAndroidAsync(...) has no effect on ${Platform.OS}`);\n      return Promise.resolve();\n    }\n    // This codepath will never be triggered in SDK 28 and above\n    // TODO: remove before releasing\n    if (!IS_USING_NEW_BINARY) {\n      return Promise.resolve();\n    }\n    return ExponentNotifications.deleteChannel(id);\n  },\n\n  /* Shows a notification instantly */\n  async presentLocalNotificationAsync(\n    notification: LocalNotification\n  ): Promise<LocalNotificationId> {\n    _validateNotification(notification);\n    const nativeNotification = _processNotification(notification);\n\n    if (Platform.OS !== 'android') {\n      return await ExponentNotifications.presentLocalNotification(nativeNotification);\n    } else {\n      let _channel;\n      if (nativeNotification.channelId) {\n        _channel = await _legacyReadChannel(nativeNotification.channelId);\n      }\n\n      if (IS_USING_NEW_BINARY) {\n        // delete the legacy channel from AsyncStorage so this codepath isn't triggered anymore\n        _legacyDeleteChannel(nativeNotification.channelId);\n        return ExponentNotifications.presentLocalNotificationWithChannel(\n          nativeNotification,\n          _channel\n        );\n      } else {\n        // TODO: remove this codepath before releasing, it will never be triggered on SDK 28+\n        // channel does not actually exist, so add its settings to the individual notification\n        if (_channel) {\n          nativeNotification.sound = _channel.sound;\n          nativeNotification.priority = _channel.priority;\n          nativeNotification.vibrate = _channel.vibrate;\n        }\n        return ExponentNotifications.presentLocalNotification(nativeNotification);\n      }\n    }\n  },\n\n  /* Schedule a notification at a later date */\n  async scheduleLocalNotificationAsync(\n    notification: LocalNotification,\n    options: {\n      time?: Date | number;\n      repeat?: 'minute' | 'hour' | 'day' | 'week' | 'month' | 'year';\n      intervalMs?: number;\n    } = {}\n  ): Promise<LocalNotificationId> {\n    // set now at the beginning of the method, to prevent potential weird warnings when we validate\n    // options.time later on\n    const now = Date.now();\n\n    // Validate and process the notification data\n    _validateNotification(notification);\n    const nativeNotification = _processNotification(notification);\n\n    // Validate `options.time`\n    if (options.time) {\n      let timeAsDateObj: Date | null = null;\n      if (options.time && typeof options.time === 'number') {\n        timeAsDateObj = new Date(options.time);\n        if (timeAsDateObj.toString() === 'Invalid Date') {\n          timeAsDateObj = null;\n        }\n      } else if (options.time && options.time instanceof Date) {\n        timeAsDateObj = options.time;\n      }\n\n      // If we couldn't convert properly, throw an error\n      if (!timeAsDateObj) {\n        throw new Error(\n          `Provided value for \"time\" is invalid. Please verify that it's either a number representing Unix Epoch time in milliseconds, or a valid date object.`\n        );\n      }\n\n      // If someone passes in a value that is too small, say, by an order of 1000 (it's common to\n      // accidently pass seconds instead of ms), display a warning.\n      if (timeAsDateObj.getTime() < now) {\n        console.warn(\n          `Provided value for \"time\" is before the current date. Did you possibly pass number of seconds since Unix Epoch instead of number of milliseconds?`\n        );\n      }\n\n      options = {\n        ...options,\n        time: timeAsDateObj.getTime(),\n      };\n    }\n\n    if (options.intervalMs != null && options.repeat != null) {\n      throw new Error(`Pass either the \"repeat\" option or \"intervalMs\" option, not both`);\n    }\n\n    // Validate options.repeat\n    if (options.repeat != null) {\n      const validOptions = new Set(['minute', 'hour', 'day', 'week', 'month', 'year']);\n      if (!validOptions.has(options.repeat)) {\n        throw new Error(\n          `Pass one of ['minute', 'hour', 'day', 'week', 'month', 'year'] as the value for the \"repeat\" option`\n        );\n      }\n    }\n\n    if (options.intervalMs != null) {\n      if (Platform.OS === 'ios') {\n        throw new Error(`The \"intervalMs\" option is not supported on iOS`);\n      }\n\n      if (options.intervalMs <= 0 || !Number.isInteger(options.intervalMs)) {\n        throw new Error(\n          `Pass an integer greater than zero as the value for the \"intervalMs\" option`\n        );\n      }\n    }\n\n    if (Platform.OS !== 'android') {\n      if (options.repeat) {\n        console.warn(\n          'Ability to schedule an automatically repeated notification is deprecated on iOS and will be removed in the next SDK release.'\n        );\n        return ExponentNotifications.legacyScheduleLocalRepeatingNotification(\n          nativeNotification,\n          options\n        );\n      }\n\n      return ExponentNotifications.scheduleLocalNotification(nativeNotification, options);\n    } else {\n      let _channel;\n      if (nativeNotification.channelId) {\n        _channel = await _legacyReadChannel(nativeNotification.channelId);\n      }\n\n      if (IS_USING_NEW_BINARY) {\n        // delete the legacy channel from AsyncStorage so this codepath isn't triggered anymore\n        _legacyDeleteChannel(nativeNotification.channelId);\n        return ExponentNotifications.scheduleLocalNotificationWithChannel(\n          nativeNotification,\n          options,\n          _channel\n        );\n      } else {\n        // TODO: remove this codepath before releasing, it will never be triggered on SDK 28+\n        // channel does not actually exist, so add its settings to the individual notification\n        if (_channel) {\n          nativeNotification.sound = _channel.sound;\n          nativeNotification.priority = _channel.priority;\n          nativeNotification.vibrate = _channel.vibrate;\n        }\n        return ExponentNotifications.scheduleLocalNotification(nativeNotification, options);\n      }\n    }\n  },\n\n  /* Dismiss currently shown notification with ID (Android only) */\n  async dismissNotificationAsync(notificationId: LocalNotificationId): Promise<void> {\n    if (!ExponentNotifications.dismissNotification) {\n      throw new UnavailabilityError('Expo.Notifications', 'dismissNotification');\n    }\n    return await ExponentNotifications.dismissNotification(notificationId);\n  },\n\n  /* Dismiss all currently shown notifications (Android only) */\n  async dismissAllNotificationsAsync(): Promise<void> {\n    if (!ExponentNotifications.dismissAllNotifications) {\n      throw new UnavailabilityError('Expo.Notifications', 'dismissAllNotifications');\n    }\n    return await ExponentNotifications.dismissAllNotifications();\n  },\n\n  /* Cancel scheduled notification notification with ID */\n  cancelScheduledNotificationAsync(notificationId: LocalNotificationId): Promise<void> {\n    if (Platform.OS === 'android' && typeof notificationId === 'string') {\n      return ExponentNotifications.cancelScheduledNotificationWithStringIdAsync(notificationId);\n    }\n    return ExponentNotifications.cancelScheduledNotificationAsync(notificationId);\n  },\n\n  /* Cancel all scheduled notifications */\n  cancelAllScheduledNotificationsAsync(): Promise<void> {\n    return ExponentNotifications.cancelAllScheduledNotificationsAsync();\n  },\n\n  /* Primary public api */\n  addListener(listener: (notification: Notification) => unknown): EventSubscription {\n    _maybeInitEmitter();\n\n    if (_initialNotification) {\n      const initialNotification = _initialNotification;\n      _initialNotification = null;\n      setTimeout(() => {\n        emitNotification(initialNotification);\n      }, 0);\n    }\n\n    return _emitter.addListener('notification', listener);\n  },\n\n  async getBadgeNumberAsync(): Promise<number> {\n    if (!ExponentNotifications.getBadgeNumberAsync) {\n      return 0;\n    }\n    return ExponentNotifications.getBadgeNumberAsync();\n  },\n\n  async setBadgeNumberAsync(number: number): Promise<void> {\n    if (!ExponentNotifications.setBadgeNumberAsync) {\n      throw new UnavailabilityError('Expo.Notifications', 'setBadgeNumberAsync');\n    }\n    return ExponentNotifications.setBadgeNumberAsync(number);\n  },\n\n  async scheduleNotificationWithCalendarAsync(\n    notification: LocalNotification,\n    options: {\n      year?: number;\n      month?: number;\n      hour?: number;\n      day?: number;\n      minute?: number;\n      second?: number;\n      weekDay?: number;\n      repeat?: boolean;\n    } = {}\n  ): Promise<string> {\n    const areOptionsValid: boolean =\n      (options.month == null || isInRangeInclusive(options.month, 1, 12)) &&\n      (options.day == null || isInRangeInclusive(options.day, 1, 31)) &&\n      (options.hour == null || isInRangeInclusive(options.hour, 0, 23)) &&\n      (options.minute == null || isInRangeInclusive(options.minute, 0, 59)) &&\n      (options.second == null || isInRangeInclusive(options.second, 0, 59)) &&\n      (options.weekDay == null || isInRangeInclusive(options.weekDay, 1, 7)) &&\n      (options.weekDay == null || options.day == null);\n\n    if (!areOptionsValid) {\n      throw new CodedError(\n        'WRONG_OPTIONS',\n        'Options in scheduleNotificationWithCalendarAsync call were incorrect!'\n      );\n    }\n\n    _validateNotification(notification);\n    const nativeNotification = _processNotification(notification);\n\n    return ExponentNotifications.scheduleNotificationWithCalendar(nativeNotification, options);\n  },\n\n  async scheduleNotificationWithTimerAsync(\n    notification: LocalNotification,\n    options: {\n      interval: number;\n      repeat?: boolean;\n    }\n  ): Promise<string> {\n    if (options.interval < 1) {\n      throw new CodedError('WRONG_OPTIONS', 'Interval must be not less then 1');\n    }\n\n    _validateNotification(notification);\n    const nativeNotification = _processNotification(notification);\n\n    return ExponentNotifications.scheduleNotificationWithTimer(nativeNotification, options);\n  },\n};\n\nfunction isInRangeInclusive(variable: number, min: number, max: number): boolean {\n  return variable >= min && variable <= max;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}